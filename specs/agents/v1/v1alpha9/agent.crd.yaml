apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: agents.agents.enterprise.com
spec:
  group: agents.enterprise.com
  scope: Namespaced
  names:
    kind: Agent
    listKind: AgentList
    plural: agents
    singular: agent
    shortNames: [ag]
  versions:
  - name: v1alpha9
    served: true
    storage: true
    subresources:
      status: {}
    additionalPrinterColumns:
    - name: Version
      type: string
      jsonPath: .spec.identity.version
    - name: Env
      type: string
      jsonPath: .spec.context.environment
    - name: Phase
      type: string
      jsonPath: .status.phase
    schema:
      openAPIV3Schema:
        description: Agent defines an AI Agent as configuration-as-code.
        type: object
        properties:
          apiVersion: { type: string }
          kind: { type: string }
          metadata: { type: object }
          spec:
            type: object
            description: AgentSpec
            # Validation rules for internal consistency
            x-kubernetes-validations:
              # Validation: If tools is present, it must be an array (defensive, optional)
              - rule: "!has(self.tools) || self.tools is list"
                message: "tools must be an array if present."
              # Validation: If mcpServers is present, it must be an array (defensive, optional)
              - rule: "!has(self.mcpServers) || self.mcpServers is list"
                message: "mcpServers must be an array if present."
              # Validation: If both tools and mcpServers are present, each tool with mcp.serverRef must reference an existing MCP server by urn or uuid.
              - rule: |
                  !has(self.tools) ||
                  !has(self.mcpServers) ||
                  self.tools.all(t,
                    !has(t.mcp) ||
                    !has(t.mcp.serverRef) ||
                    (
                      (has(t.mcp.serverRef.urn) &&
                        self.mcpServers.exists(s,
                          has(s.identity) &&
                          has(s.identity.urn) &&
                          s.identity.urn == t.mcp.serverRef.urn
                        )
                      )
                      ||
                      (has(t.mcp.serverRef.uuid) &&
                        self.mcpServers.exists(s,
                          has(s.identity) &&
                          has(s.identity.uuid) &&
                          s.identity.uuid == t.mcp.serverRef.uuid
                        )
                      )
                    )
                  )
                message: "Each tool must reference an existing MCP server via tools[].mcp.serverRef (urn or uuid)."
              # If llm.gatewayRef is present, it must match an entry in llmGateways
              - rule: "(!has(self.llm) || !has(self.llm.gatewayRef)) || (has(self.llmGateways) && ((has(self.llm.gatewayRef.urn) && self.llmGateways.exists(g, has(g.identity) && has(g.identity.urn) && g.identity.urn == self.llm.gatewayRef.urn)) || (has(self.llm.gatewayRef.uuid) && self.llmGateways.exists(g, has(g.identity) && has(g.identity.uuid) && g.identity.uuid == self.llm.gatewayRef.uuid))))"
                message: "llm.gatewayRef must match an llmGateways entry (urn or uuid)."
            required: [ownership, role, goal, systemPrompt, llm] # Core agent definition
            properties:
              schemaVersion:
                type: string
                description: The version of the Agent schema (e.g., v1alpha9).
              identity: # Stable identity & provenance
                type: object
                description: Provides a stable identity and provenance information for the agent.
                properties:
                  urn: { type: string, description: "Unique Resource Name for the agent." }
                  uuid: { type: string, format: uuid, description: "Universally Unique Identifier for the agent." }
                  displayName: { type: string, description: "Human-readable name for the agent." }
                  icon: { type: string, description: "URL to an icon representing the agent." }
                  version: { type: string, description: "Semantic version of the agent definition." }
                  git: # Provenance from Git
                    type: object
                    properties:
                      repo: { type: string, description: "Git repository URL." }
                      path: { type: string, description: "Path within the repository." }
                      ref:  { type: string, description: "Git branch or tag (e.g., refs/heads/main)." }
                      commit: { type: string, description: "Specific Git commit hash." }
                  ownerContacts: # Contact points
                    type: array
                    items: { type: string, description: "Contact email or identifier for the owner." }
                  createdAt: { type: string, format: date-time, description: "Timestamp of agent creation." }
                  updatedAt: { type: string, format: date-time, description: "Timestamp of last agent update." }
                x-kubernetes-validations: # Ensure identity is provided
                  - rule: "has(self.urn) || has(self.uuid)"
                    message: "Provide identity.urn or identity.uuid."
              context: # Deployment/operational context
                type: object
                properties:
                  tenantId: { type: string, description: "Tenant identifier for multi-tenancy." }
                  workspaceId: { type: string, description: "Workspace identifier within a tenant." }
                  environment: # Operational environment
                    type: string
                    enum: [playground, dev, test, stage, prod]
                    description: "The environment the agent is intended for."
                  labels: # Key-value labels for organization
                    type: object
                    additionalProperties: { type: string }
                  tags: # Simple tags
                    type: array
                    items: { type: string }
                  lifecycle: # Lifecycle stage
                    type: string
                    enum: [ideation, prototype, development, testing, staging, prod]
                    description: "Current lifecycle stage of the agent."
              ownership: # Ownership details
                type: object
                required: [team]
                properties:
                  organization: { type: string, description: "Owning organization." }
                  team: { type: string, description: "Owning team (required)." }
                  user: { type: string, description: "Primary contact user." }
                  sloEmail: { type: string, description: "Email for SLO notifications." }
                  askId: { type: string, description: "Internal identifier for the originating request/ask." }
              role: { type: string, description: "The designated role or title of the agent (e.g., 'Senior Clinical Coder')." }
              goal: { type: string, description: "The primary objective or task the agent is designed to accomplish." }
              backstory: { type: string, description: "An optional narrative background that provides context and personality to the agent." }
              systemPrompt: { type: string, description: "The core system prompt or instructions that define the agent's behavior and operational guidelines." }
              promptTemplateRef: { type: string, description: "A reference to a prompt template in the central POML library (e.g., 'prompts/poml/clinical/summarize-note.poml'). This is an alternative to an inline systemPrompt." }
              persona: # Agent personality traits
                type: object
                properties:
                  agentType: { type: string, description: "High-level agent type (e.g., Analyst, Assistant, ToolUser)." }
                  tone: { type: string, description: "Desired communication tone (e.g., Formal, Friendly, Technical)." }
                  topics: # Relevant topics
                    type: array
                    items: { type: string, description: "Topics the agent is knowledgeable about or focused on." }
              ioConfig: # Input/Output configuration
                type: object
                properties:
                  inputs: # Supported input formats
                    type: array
                    items:
                      type: object
                      properties:
                        format: # Format type
                          type: string
                          enum: [text, file, image, audio, video, json, xml]
                          description: "Supported input format."
                        schemaDefinition: { type: string, description: "Inline JSON Schema definition for structured inputs." }
                        schemaRef: { type: string, description: "Reference to an external schema definition." }
                        contentTypes: # MIME types for file formats
                          type: array
                          items: { type: string, description: "Specific MIME types (e.g., application/pdf, text/csv)." }
                  outputs: # Supported output formats
                    type: array
                    items:
                      type: object
                      properties:
                        format: # Format type
                          type: string
                          enum: [text, file, image, audio, video, json, xml]
                          description: "Supported output format."
                        schemaDefinition: { type: string, description: "Inline JSON Schema definition for structured outputs." }
                        schemaRef: { type: string, description: "Reference to an external schema definition." }
                        contentTypes: # MIME types for file formats
                          type: array
                          items: { type: string, description: "Specific MIME types (e.g., application/json, image/png)." }
              behavior: # Fine-grained agent behavior control
                type: object
                properties:
                  responseFormat: # Desired output format from LLM
                    type: object
                    properties:
                      type: { type: string, enum: [text, json, xml], description: "Desired LLM response format." }
                      jsonSchemaRef: { type: string, description: "Reference to a JSON schema for structured LLM output." }
                  toolChoice: { type: string, enum: [auto, required, none], description: "Control how the agent uses tools." }
                  reasoning: # LLM reasoning features
                    type: object
                    properties:
                      enabled: { type: boolean, description: "Enable advanced reasoning features (if supported by LLM)." }
                      maxReasoningTokens: { type: integer, description: "Maximum tokens to allocate for reasoning." }
                  determinism: # Control for reproducibility
                    type: object
                    properties:
                      seed: { type: integer, description: "Seed for LLM sampling (if supported)." }
                      idempotencyKey: { type: string, description: "Key to ensure idempotent requests." }
                  contextWindow: # Context management
                    type: object
                    properties:
                      maxPromptTokens: { type: integer, description: "Maximum tokens allowed in the prompt." }
                      truncationStrategy: { type: string, enum: [front, middle, back], description: "How to truncate context if needed." }
              llmGateways: # List of available LLM gateways
                type: array
                items:
                  type: object
                  required: [identity, endpoint, authentication]
                  properties:
                    identity: # Gateway identity
                      type: object
                      properties:
                        urn: { type: string, description: "Unique Resource Name for the gateway." }
                        uuid: { type: string, format: uuid, description: "Universally Unique Identifier for the gateway." }
                        displayName: { type: string, description: "Human-readable name for the gateway." }
                      x-kubernetes-validations: # Ensure identity is provided
                        - rule: "has(self.urn) || has(self.uuid)"
                          message: "Provide gateway identity URN or UUID."
                    endpoint: { type: string, description: "Base URL for the LLM gateway API." }
                    vendor: { type: string, description: "LLM vendor (e.g., OpenAI, Anthropic)." }
                    apiVersion: { type: string, description: "API version of the gateway." }
                    defaultModel: { type: string, description: "Default model to use if not specified in `llm`." }
                    models: # Supported models
                      type: array
                      items: { type: string, description: "List of models supported by this gateway." }
                    authentication: # Authentication for the gateway
                      type: object
                      required: [type]
                      properties:
                        type: { type: string, enum: [OAuth2.1, ApiKey, OIDC, ManagedIdentity, None], description: "Authentication type." }
                        oauth2_1: # OAuth2.1 specific config
                          type: object
                          properties:
                            clientId: { type: string, description: "Client ID (if static)." }
                            clientSecretRef: # Reference to secret for client secret
                              type: object
                              required: [keyName]
                              properties: { keyName: { type: string, description: "Key name within the secret." } }
                            tokenUrl: { type: string, description: "Token endpoint URL." }
                            scope: { type: string, description: "OAuth scope." }
                        apiKey: # API Key specific config
                          type: object
                          properties:
                            headerName: { type: string, description: "Header name for the API key." }
                            secretRef: # Reference to secret for API key
                              type: object
                              required: [keyName]
                              properties: { keyName: { type: string, description: "Key name within the secret." } }
                        oidc: # OIDC specific config
                          type: object
                          properties:
                            issuer: { type: string, description: "OIDC Issuer URL." }
                            audience: { type: string, description: "Intended audience for the token." }
                            clientId: { type: string, description: "Client ID (if static)." }
                            clientSecretRef: # Reference to secret for client secret
                              type: object
                              required: [keyName]
                              properties: { keyName: { type: string, description: "Key name within the secret." } }
                        managedIdentity: # Managed Identity specific config
                          type: object
                          properties:
                            clientId: { type: string, description: "Client ID of the managed identity." }
                      x-kubernetes-validations: # Ensure correct auth config is provided
                        - rule: "self.type != 'OAuth2.1' || has(self.oauth2_1)"
                          message: "OAuth2.1 selected but oauth2_1 missing."
                        - rule: "self.type != 'ApiKey'   || has(self.apiKey)"
                          message: "ApiKey selected but apiKey missing."
                        - rule: "self.type != 'OIDC'     || has(self.oidc)"
                          message: "OIDC selected but oidc missing."
              llm: # LLM configuration for this agent
                type: object
                required: [model]
                properties:
                  provider: # Direct LLM provider (alternative to gateway)
                    type: string
                    enum: [AmazonBedrock, Anthropic, AzureOpenAI, Cohere, GoogleVertexAI, Local, Meta, MistralAI, Ollama, OpenAI]
                    description: "Direct LLM provider (alternative to using a gateway)."
                  gatewayRef: # Reference to an LLM gateway
                    type: object
                    properties:
                      urn: { type: string, description: "URN of the LLM gateway to use." }
                      uuid: { type: string, format: uuid, description: "UUID of the LLM gateway to use." }
                    x-kubernetes-validations: # Ensure gateway reference is provided
                      - rule: "has(self.urn) || has(self.uuid)"
                        message: "gatewayRef requires URN or UUID."
                  model: { type: string, description: "Specific model name to use." }
                  parameters: # LLM generation parameters
                    type: object
                    properties:
                      temperature: { type: number, description: "Sampling temperature." }
                      topP: { type: number, description: "Top-p (nucleus) sampling." }
                      maxTokens: { type: integer, description: "Maximum number of tokens to generate." }
                      stopSequences: # Sequences to stop generation
                        type: array
                        items: { type: string, description: "Sequence to stop generation." }
                x-kubernetes-validations: # Ensure either provider or gateway is specified
                  - rule: "has(self.provider) || has(self.gatewayRef)"
                    message: "Provide either llm.provider or llm.gatewayRef."
              mcpServers: # List of Model Context Protocol (MCP) servers
                type: array
                items:
                  type: object
                  required: [identity, url, authentication]
                  properties:
                    identity: # MCP server identity
                      type: object
                      properties:
                        urn: { type: string, description: "Unique Resource Name for the MCP server." }
                        uuid: { type: string, format: uuid, description: "Universally Unique Identifier for the MCP server." }
                        displayName: { type: string, description: "Human-readable name for the MCP server." }
                      x-kubernetes-validations: # Ensure identity is provided
                        - rule: "has(self.urn) || has(self.uuid)"
                          message: "Provide MCP identity URN or UUID."
                    name: { type: string, description: "DEPRECATED: This field will be removed in a future release (target: v1beta). Please migrate to using 'identity.displayName' instead. For migration, copy the value of 'name' to 'identity.displayName' and update your manifests accordingly." }
                    url: { type: string, description: "Base URL for the MCP server." }
                    protocol: { type: string, enum: [http, https, ws, wss, grpc], description: "Communication protocol." }
                    authentication: # Authentication for the MCP server
                      type: object
                      required: [type]
                      properties:
                        type: { type: string, enum: [OAuth2.1, ApiKey, OIDC, ManagedIdentity, None], description: "Authentication type." }
                        oauth2_1: # OAuth2.1 specific config
                          type: object
                          properties:
                            clientId: { type: string, description: "Client ID (if static)." }
                            clientSecretRef: # Reference to secret for client secret
                              type: object
                              required: [keyName]
                              properties: { keyName: { type: string, description: "Key name within the secret." } }
                            tokenUrl: { type: string, description: "Token endpoint URL." }
                            scope: { type: string, description: "OAuth scope." }
                        apiKey: # API Key specific config
                          type: object
                          properties:
                            headerName: { type: string, description: "Header name for the API key." }
                            secretRef: # Reference to secret for API key
                              type: object
                              required: [keyName]
                              properties: { keyName: { type: string, description: "Key name within the secret." } }
                        oidc: # OIDC specific config
                          type: object
                          properties:
                            issuer: { type: string, description: "OIDC Issuer URL." }
                            audience: { type: string, description: "Intended audience for the token." }
                            clientId: { type: string, description: "Client ID (if static)." }
                            clientSecretRef: # Reference to secret for client secret
                              type: object
                              required: [keyName]
                              properties: { keyName: { type: string, description: "Key name within the secret." } }
                        managedIdentity: # Managed Identity specific config
                          type: object
                          properties:
                            clientId: { type: string, description: "Client ID of the managed identity." }
                      x-kubernetes-validations: # Ensure correct auth config is provided
                        - rule: "self.type != 'OAuth2.1' || has(self.oauth2_1)"
                          message: "OAuth2.1 selected but oauth2_1 missing."
                        - rule: "self.type != 'ApiKey'   || has(self.apiKey)"
                          message: "ApiKey selected but apiKey missing."
                        - rule: "self.type != 'OIDC'     || has(self.oidc)"
                          message: "OIDC selected but oidc missing."
              tools: # Tools bound to this agent (from MCP servers)
                type: array
                description: "MCP tool bindings for this agent."
                items:
                  type: object
                  required: [name, mcp]
                  properties:
                    identity: # Tool identity
                      type: object
                      properties:
                        urn: { type: string, description: "Unique Resource Name for the tool." }
                        uuid: { type: string, format: uuid, description: "Universally Unique Identifier for the tool." }
                      x-kubernetes-validations: # Ensure identity is provided
                        - rule: "has(self.urn) || has(self.uuid)"
                          message: "Provide tool identity URN or UUID."
                    name: { type: string, description: "Name of the tool binding within the agent." }
                    description: { type: string, description: "Description of the tool's purpose for this agent." }
                    mcp: # MCP-specific tool configuration
                      type: object
                      required: [serverRef, toolName]
                      properties:
                        serverRef: # Reference to the MCP server
                          type: object
                          properties:
                            urn: { type: string, description: "URN of the MCP server providing the tool." }
                            uuid: { type: string, format: uuid, description: "UUID of the MCP server providing the tool." }
                          x-kubernetes-validations: # Ensure server reference is provided
                            - rule: "has(self.urn) || has(self.uuid)"
                              message: "serverRef requires URN or UUID."
                        toolName: { type: string, description: "Name of the tool as defined by the MCP server." }
                        version: { type: string, description: "Specific version of the tool to use (if supported)." }
                        schemaHash: { type: string, description: "Hash of the tool schema for validation (if supported)." }
                    defaults: # Default parameters for the tool
                      type: object
                      additionalProperties: true
                      description: "Default parameter values for the tool call."
                    parameterMapping: # Mapping input to tool parameters
                      type: object
                      additionalProperties: { type: object }
                      description: "Mapping from agent/tool input to specific tool parameters."
                    timeoutMs: { type: integer, description: "Timeout for the tool call in milliseconds." }
                    retries: { type: integer, description: "Number of retries for the tool call." }
                    cacheTTL: { type: integer, description: "Cache time-to-live for tool results in seconds." }
                    limits: # Rate/concurrency limits for the tool
                      type: object
                      properties:
                        rpm: { type: integer, description: "Rate limit: requests per minute." }
                        concurrency: { type: integer, description: "Maximum concurrent calls." }
                    authOverride: # Override authentication for this tool
                      type: object
                      properties:
                        type: { type: string, enum: [ApiKey, OAuth2.1, OIDC, ManagedIdentity, None], description: "Authentication type override." }
                        secretRef: # Reference to secret for override auth
                          type: object
                          required: [keyName]
                          properties: { keyName: { type: string, description: "Key name within the secret." } }
              knowledgeBases: # List of knowledge bases the agent can access
                type: array
                items:
                  type: object
                  required: [name, type]
                  properties:
                    identity: # Knowledge base identity
                      type: object
                      properties:
                        urn: { type: string, description: "Unique Resource Name for the knowledge base." }
                        uuid: { type: string, format: uuid, description: "Universally Unique Identifier for the knowledge base." }
                    name: { type: string, description: "Name of the knowledge base binding within the agent." }
                    type: { type: string, enum: [AzureBlobVectorize, PostgresPgvector, AzureCosmosDb, AzureAISearch], description: "Type of knowledge base." }
                    connection: # Connection details (using secret refs)
                      type: object
                      properties:
                        connectionStringSecretRef: # Reference to connection string secret
                          type: object
                          required: [keyName]
                          properties: { keyName: { type: string, description: "Key name within the secret." } }
                        endpoint: { type: string, description: "Endpoint URL (if applicable)." }
                        database: { type: string, description: "Database name (if applicable)." }
                        index: { type: string, description: "Index name (if applicable)." }
                    indexing: # Indexing configuration
                      type: object
                      properties:
                        autoIngest: { type: boolean, description: "Enable automatic ingestion of new data." }
                        schedule: { type: string, description: "Cron-like schedule for ingestion." }
              rag: # Retrieval-Augmented Generation (RAG) configuration
                type: object
                properties:
                  ingestion: # Data ingestion settings
                    type: object
                    properties:
                      chunker: { type: string, enum: [token, sentence, semantic], description: "Method for chunking text." }
                      chunkSize: { type: integer, description: "Size of each text chunk." }
                      chunkOverlap: { type: integer, description: "Overlap between chunks." }
                      dedupe: { type: boolean, description: "Enable duplicate detection/removal." }
                      schedule: { type: string, description: "Cron-like schedule for ingestion." }
                  embedding: # Embedding model settings
                    type: object
                    properties:
                      model: { type: string, description: "Model used for generating embeddings." }
                      dimension: { type: integer, description: "Dimensionality of the embeddings." }
                  index: # Vector index settings
                    type: object
                    properties:
                      metric: { type: string, enum: [cosine, dot, euclidean], description: "Distance metric for similarity search." }
                      hnsw: # HNSW index parameters
                        type: object
                        properties:
                          m: { type: integer, description: "Number of bi-directional links created for every new element." }
                          efConstruction: { type: integer, description: "Size of the dynamic candidate list for construction." }
                      ivf: # IVF index parameters
                        type: object
                        properties:
                          nlist: { type: integer, description: "Number of clusters." }
                          nprobe: { type: integer, description: "Number of clusters to probe during search." }
                      hybrid: { type: boolean, description: "Enable hybrid search (keyword + vector)." }
                  retrieval: # Retrieval settings
                    type: object
                    properties:
                      topK: { type: integer, description: "Number of top results to retrieve." }
                      mmr: { type: boolean, description: "Use Maximal Marginal Relevance for diversity." }
                      filtersRef: { type: string, description: "Reference to retrieval filters." }
                      recencyBoost: { type: boolean, description: "Boost score of more recent documents." }
                      requireCitations: { type: boolean, description: "Require retrieved documents to be cited in the output." }
                  retention: # Data retention settings
                    type: object
                    properties:
                      ttlDays: { type: integer, description: "Time-to-live for indexed data in days." }
                      lineage: { type: boolean, description: "Track data lineage." }
              api: # API endpoints exposed by the agent
                type: object
                properties:
                  openapiRef: { type: string, format: uri, description: "Reference to an OpenAPI specification for the agent's API." }
                  endpoints: # Specific API endpoints
                    type: array
                    items:
                      type: object
                      required: [name, method, path]
                      properties:
                        name: # Endpoint name/function
                          type: string
                          enum: [ingest, upsert, query, retrieve, chat, run, evaluate]
                          description: "Standardized name for the endpoint function."
                        method: # HTTP method
                          type: string
                          enum: [GET, POST, PUT, DELETE, PATCH]
                          description: "HTTP method for the endpoint."
                        path: { type: string, description: "Path for the endpoint (e.g., /api/v1/query)." }
                        contentTypes: # Supported content types
                          type: array
                          items: { type: string, description: "MIME type (e.g., application/json)." }
                        authScopes: # Required authentication scopes
                          type: array
                          items: { type: string, description: "OAuth scope required for this endpoint." }
                        rateLimit: # Rate limiting for the endpoint
                          type: object
                          properties:
                            rpm: { type: integer, description: "Requests per minute limit." }
                            rps: { type: integer, description: "Requests per second limit." }
                        streaming: { type: boolean, description: "Indicates if the endpoint supports streaming responses." }
                        errorModelRef: { type: string, description: "Reference to the error model for this endpoint." }
              a2aRegistries: # List of Agent-to-Agent (A2A) registries
                type: array
                items:
                  type: object
                  required: [identity, url, authentication]
                  properties:
                    identity: # Registry identity
                      type: object
                      properties:
                        urn: { type: string, description: "Unique Resource Name for the A2A registry." }
                        uuid: { type: string, format: uuid, description: "Universally Unique Identifier for the A2A registry." }
                        displayName: { type: string, description: "Human-readable name for the registry." }
                      x-kubernetes-validations: # Ensure identity is provided
                        - rule: "has(self.urn) || has(self.uuid)"
                          message: "Provide registry identity URN or UUID."
                    url: { type: string, description: "Base URL for the A2A registry." }
                    protocol: { type: string, enum: [http, https, ws, wss, grpc], description: "Communication protocol." }
                    authentication: # Authentication for the registry
                      type: object
                      required: [type]
                      properties:
                        type: { type: string, enum: [OAuth2.1, ApiKey, OIDC, ManagedIdentity, None], description: "Authentication type." }
                        oauth2_1:
                          type: object
                          description: "OAuth2.1 configuration."
                          properties:
                            clientId: { type: string, description: "OAuth2.1 client ID." }
                            clientSecretRef: { type: string, description: "Reference to a Kubernetes Secret containing the client secret." }
                            tokenUrl: { type: string, format: uri, description: "OAuth2.1 token endpoint URL." }
                            scopes:
                              type: array
                              items: { type: string, description: "OAuth2.1 scope." }
                          required: [clientId, clientSecretRef, tokenUrl]
                        apiKey:
                          type: object
                          description: "API Key configuration."
                          properties:
                            keyHeader: { type: string, description: "HTTP header to use for the API key." }
                            keyValueRef: { type: string, description: "Reference to a Kubernetes Secret containing the API key value." }
                          required: [keyHeader, keyValueRef]
                        oidc:
                          type: object
                          description: "OIDC configuration."
                          properties:
                            issuerUrl: { type: string, format: uri, description: "OIDC issuer URL." }
                            clientId: { type: string, description: "OIDC client ID." }
                            clientSecretRef: { type: string, description: "Reference to a Kubernetes Secret containing the client secret." }
                            scopes:
                              type: array
                              items: { type: string, description: "OIDC scope." }
                          required: [issuerUrl, clientId, clientSecretRef]
                        managedIdentity:
                          type: object
                          description: "Managed Identity configuration."
                          properties:
                            clientId: { type: string, description: "Managed Identity client ID." }
                            resource: { type: string, description: "Resource for which the managed identity is used." }
                          required: [clientId, resource]
              a2a: # A2A capabilities and configuration for this agent
                type: object
                properties:
                  card: # Agent's A2A capability card
                    type: object
                    required: [protocolVersion, preferredInterface, defaultInputModes, defaultOutputModes, skills]
                    properties:
                      protocolVersion: { type: string, description: "Version of the A2A protocol supported." }
                      name: { type: string, description: "Name of the agent for A2A interactions." }
                      description: { type: string, description: "Description of the agent for A2A interactions." }
                      version: { type: string, description: "Version of the agent for A2A interactions." }
                      iconUrl: { type: string, description: "URL to the agent's icon for A2A interactions." }
                      documentationUrl: { type: string, description: "URL to the agent's documentation for A2A interactions." }
                      provider: # Provider information
                        type: object
                        properties:
                          organization: { type: string, description: "Organization providing the agent." }
                          url: { type: string, description: "URL of the provider organization." }
                      preferredInterface: # Preferred communication interface
                        type: object
                        required: [url, transport]
                        properties:
                          url: { type: string, description: "URL for the preferred interface." }
                          transport: { type: string, enum: ["JSONRPC","GRPC","HTTP+JSON"], description: "Transport protocol for the interface." }
                      additionalInterfaces: # Other supported interfaces
                        type: array
                        items:
                          type: object
                          required: [url, transport]
                          properties:
                            url: { type: string, description: "URL for the additional interface." }
                            transport: { type: string, enum: ["JSONRPC","GRPC","HTTP+JSON"], description: "Transport protocol for the interface." }
                      capabilities: # Supported capabilities
                        type: object
                        properties:
                          streaming: { type: boolean, description: "Supports streaming responses." }
                          pushNotifications: { type: boolean, description: "Supports push notifications." }
                          stateTransitionHistory: { type: boolean, description: "Provides state transition history." }
                          extensions: # Protocol extensions
                            type: array
                            items:
                              type: object
                              required: [uri]
                              properties:
                                uri: { type: string, description: "URI identifying the extension." }
                                description: { type: string, description: "Description of the extension." }
                                required: { type: boolean, description: "Whether the extension is required." }
                                params: { type: object, additionalProperties: true, description: "Parameters for the extension." }
                      securitySchemes: { type: object, additionalProperties: { type: object }, description: "Security schemes supported by the agent." }
                      security: # Security requirements
                        type: array
                        items: { type: object, additionalProperties: { type: array, items: { type: string } }, description: "Security requirements for the agent." }
                      defaultInputModes: { type: array, items: { type: string }, description: "Default input modes supported." }
                      defaultOutputModes: { type: array, items: { type: string }, description: "Default output modes supported." }
                      skills: # List of skills the agent offers via A2A
                        type: array
                        items:
                          type: object
                          required: [id, name, description, tags]
                          properties:
                            id: { type: string, description: "Unique identifier for the skill." }
                            name: { type: string, description: "Name of the skill." }
                            description: { type: string, description: "Description of the skill." }
                            tags: { type: array, items: { type: string }, description: "Tags associated with the skill." }
                            examples: { type: array, items: { type: string }, description: "Example usages of the skill." }
                            inputModes: { type: array, items: { type: string }, description: "Supported input modes for this skill." }
                            outputModes: { type: array, items: { type: string }, description: "Supported output modes for this skill." }
                            security: # Skill-specific security requirements
                              type: array
                              items: { type: object, additionalProperties: { type: array, items: { type: string } }, description: "Security requirements for this skill." }
                      supportsAuthenticatedExtendedCard: { type: boolean, description: "Indicates if the agent supports authenticated extended cards." }
                  publishTo: # Registries to publish this agent's card to
                    type: array
                    items:
                      type: object
                      required: [registryRef]
                      properties:
                        registryRef: # Reference to the registry
                          type: object
                          properties:
                            urn: { type: string, description: "URN of the registry." }
                            uuid: { type: string, format: uuid, description: "UUID of the registry." }
                          x-kubernetes-validations: # Ensure registry reference is provided
                            - rule: "has(self.urn) || has(self.uuid)"
                              message: "registryRef requires URN or UUID."
                        visibility: { type: string, enum: [private, workspace, tenant, public], description: "Visibility level in the registry." }
                  discovery: # Discovery configuration for finding other agents
                    type: object
                    properties:
                      registryRefs: # Registries to query for discovery
                        type: array
                        items:
                          type: object
                          properties:
                            urn: { type: string, description: "URN of the registry to query." }
                            uuid: { type: string, format: uuid, description: "UUID of the registry to query." }
                          x-kubernetes-validations: # Ensure registry reference is provided
                            - rule: "has(self.urn) || has(self.uuid)"
                              message: "registryRef requires URN or UUID."
                  callPolicy: # Policy for incoming A2A calls
                    type: object
                    properties:
                      allowedAgentAudiences: # Agents allowed to call this agent
                        type: array
                        items:
                          type: object
                          properties:
                            urn: { type: string, description: "URN of the allowed agent." }
                            uuid: { type: string, format: uuid, description: "UUID of the allowed agent." }
                          x-kubernetes-validations: # Ensure agent reference is provided
                            - rule: "has(self.urn) || has(self.uuid)"
                              message: "audience requires URN or UUID."
              stateManagement: # Configuration for agent memory and session state
                type: object
                properties:
                  memory: # Short-term conversational memory
                    type: object
                    properties:
                      type: { type: string, enum: [InMemory, Redis, Postgres], description: "Type of memory store." }
                      retentionPolicy: { type: string, description: "Policy for retaining memory data (e.g., 'session', 'lastN', 'timeWindow')." }
                  session: # Longer-term user session data
                    type: object
                    properties:
                      ttlSeconds: { type: integer, description: "Time-to-live for session data in seconds." }
                      store: { type: string, enum: [InMemory, Redis, Postgres], description: "Type of session store." }
              secretsProvider: # Centralized secret management
                type: object
                required: [type, azureKeyVault]
                properties:
                  type: { type: string, enum: [AzureKeyVault], description: "Type of secret provider." }
                  azureKeyVault: # Azure Key Vault specific configuration
                    type: object
                    properties:
                      vaultName: { type: string, description: "Name of the Azure Key Vault." }
                      tenantId: { type: string, description: "Azure Tenant ID for the Key Vault." }
                      useManagedIdentity: { type: boolean, description: "Use Managed Identity for authentication." }
              securityConfig: # Security configurations (guardrails, evaluations)
                type: object
                properties:
                  guardrails: # Input/Output guardrails
                    type: object
                    properties:
                      input: { type: object, description: "Configuration for input validation/analysis." }
                      output: { type: object, description: "Configuration for output validation/analysis." }
                  evaluations: # Agent performance evaluations
                    type: array
                    items:
                      type: object
                      required: [name, metric]
                      properties:
                        name: { type: string, description: "Name of the evaluation." }
                        metric: { type: string, description: "Metric to evaluate (e.g., accuracy, toxicity)." }
                        datasetRef: { type: string, description: "Reference to the evaluation dataset." }
                        schedule: { type: string, description: "Cron-like schedule for evaluation runs." }
              security: # Security policies and configurations
                type: object
                properties:
                  rbac: # Role-Based Access Control
                    type: object
                    properties:
                      roles: { type: array, items: { type: string }, description: "Roles assigned to the agent." }
                      allowedCallers: # Agents allowed to call this agent directly
                        type: array
                        items:
                          type: object
                          properties:
                            urn: { type: string, description: "URN of the allowed caller agent." }
                            uuid: { type: string, format: uuid, description: "UUID of the allowed caller agent." }
                  dataPolicy: # Data handling policies
                    type: object
                    properties:
                      classification: { type: string, enum: [Public, Internal, Confidential, PHI], description: "Data classification level." }
                      redactPII: { type: boolean, description: "Automatically redact PII from inputs/outputs." }
                      retentionDays: { type: integer, description: "Data retention period in days." }
                  egress: # Network egress policies
                    type: object
                    properties:
                      allowlist: { type: array, items: { type: string }, description: "List of allowed external domains/URLs." }
                      mtls: { type: boolean, description: "Require mutual TLS for egress connections." }
                      jwksUri: { type: string, description: "URI for JWKS for validating outbound tokens." }
                  secrets: # Secret lifecycle management
                    type: object
                    properties:
                      rotationDays: { type: integer, description: "Secret rotation interval in days." }
                      useManagedIdentity: { type: boolean, description: "Use Managed Identity for secret access." }
              ops: # Operational configurations
                type: object
                properties:
                  timeouts: # Default timeout settings
                    type: object
                    properties:
                      defaultMs: { type: integer, description: "Default timeout for operations in milliseconds." }
                  retries: # Default retry settings
                    type: object
                    properties:
                      max: { type: integer, description: "Maximum number of retries." }
                      backoffMs: { type: integer, description: "Base backoff time in milliseconds." }
                  rateLimit: # Default rate limiting
                    type: object
                    properties:
                      rpm: { type: integer, description: "Default requests per minute limit." }
                      rps: { type: integer, description: "Default requests per second limit." }
                  resources: # Resource allocation requests/limits
                    type: object
                    properties:
                      cpu: { type: string, description: "CPU request/limit (e.g., '500m', '2')." }
                      memory: { type: string, description: "Memory request/limit (e.g., '1Gi', '512Mi')." }
                      gpu: { type: string, description: "GPU request/limit (e.g., '1')." }
              telemetry: # Observability configuration
                type: object
                properties:
                  opentelemetry: # OpenTelemetry settings
                    type: object
                    properties:
                      enabled: { type: boolean, description: "Enable OpenTelemetry tracing/metrics." }
                      serviceName: { type: string, description: "Service name for telemetry." }
                  logs: # Log configuration
                    type: object
                    properties:
                      redaction: { type: boolean, description: "Enable log redaction for sensitive data." }
                  metrics: # Custom metrics to collect
                    type: array
                    items: { type: string, description: "Name of the metric to collect." }
              evaluation: # Agent evaluation settings
                type: object
                properties:
                  datasets: { type: array, items: { type: string }, description: "References to evaluation datasets." }
                  metrics: { type: array, items: { type: string }, description: "List of metrics to evaluate." }
                  thresholds: { type: object, additionalProperties: { type: number }, description: "Thresholds for evaluation metrics." }
                  gatingPolicy: { type: string, enum: [none, warn, block], description: "Policy for gating deployment based on evaluation results." }
              community: # Community-related information
                type: object
                properties:
                  docsUrl: { type: string, format: uri, description: "URL to the agent's documentation." }
                  examplesUrl: { type: string, format: uri, description: "URL to example usages." }
                  contributionGuideUrl: { type: string, format: uri, description: "URL to the contribution guide." }
                  license: { type: string, description: "License for the agent definition." }
          status:
            type: object
            description: "Observed state of the Agent."
            properties:
              phase: { type: string, description: "Current phase of the agent (e.g., Pending, Running, Failed)." }
              conditions: # Detailed status conditions
                type: array
                items:
                  type: object
                  properties:
                    type: { type: string, description: "Type of condition (e.g., Available, Progressing)." }
                    status: { type: string, description: "Status of the condition (True, False, Unknown)." }
                    lastTransitionTime: { type: string, description: "Last time the condition transitioned." }
                    reason: { type: string, description: "Machine-readable reason for the condition." }
                    message: { type: string, description: "Human-readable message for the condition." }
